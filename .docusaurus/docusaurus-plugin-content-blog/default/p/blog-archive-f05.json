{"archive":{"blogPosts":[{"id":"docker-container-security","metadata":{"permalink":"/blog/docker-container-security","source":"@site/blog/2025-12-06-docker-container-security.md","title":"Docker Container Security","description":"Docker containers have become indispensable in modern DevOps and cloud environments. They offer flexibility, scalability, and portability‚Äîbut also introduce new attack surfaces. In this blog post, you‚Äôll learn how to operate containers securely, what risks exist, and which tools and best practices you should know.","date":"2025-12-06T00:00:00.000Z","tags":[{"inline":true,"label":"docker","permalink":"/blog/tags/docker"},{"inline":true,"label":"container","permalink":"/blog/tags/container"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"devsecops","permalink":"/blog/tags/devsecops"}],"readingTime":2,"hasTruncateMarker":true,"authors":[{"name":"Reik Loeber","title":"Fullstack Developer & DevOps & DevSecOps","url":"https://github.com/reiloe","imageURL":"https://github.com/reiloe.png","key":"reiloe","page":null}],"frontMatter":{"slug":"docker-container-security","title":"Docker Container Security","authors":["reiloe"],"tags":["docker","container","security","devsecops"]},"unlisted":false,"nextItem":{"title":"Welcome to DevSecOps Unlocked","permalink":"/blog/welcome-to-devsecops-unlocked"}},"content":"<!--truncate-->\n\nDocker containers have become indispensable in modern DevOps and cloud environments. They offer flexibility, scalability, and portability‚Äîbut also introduce new attack surfaces. In this blog post, you‚Äôll learn how to operate containers securely, what risks exist, and which tools and best practices you should know.\n\n## 1. Why Is Container Security Important?\n\nContainers isolate applications, but often share the same kernel. A successful attack on one container can impact the entire host system or other containers. Typical risks include:\n\n- Insecure images\n- Weak isolation\n- Missing updates\n- Insecure networks\n- Secrets stored in containers\n\n## 2. Best Practices for Secure Docker Containers\n\n### 2.1. Use Official and Verified Images\n\n- Use images from trusted sources (e.g. Docker Hub Official, Verified Publisher)\n- Regularly check for updates and vulnerabilities\n\n### 2.2. Minimize the Attack Surface\n\n- Use slim base images (e.g., Alpine Linux)\n- Remove unnecessary packages and tools\n- Set the container user to a non-root user (`USER` directive in the Dockerfile)\n\n### 2.3. Keep Containers and Images Up to Date\n\n- Automate updates and security scans\n- Remove outdated and unused images\n\n### 2.4. Network Security\n\n- Use dedicated Docker networks for sensitive services\n- Set firewall rules and network policies\n- Avoid exposing ports to the outside unless necessary\n\n### 2.5. Secrets Management\n\n- Do not store passwords, keys, or tokens in the image\n- Use Docker Secrets, vaults, or environment variables\n\n### 2.6. Logging & Monitoring\n\n- Monitor containers for suspicious activity\n- Use centralized logging and monitoring solutions (e.g., ELK, Prometheus, Grafana)\n\n## 3. Tools for Container Security\n\n### 3.1. Image Scanning\n\n- **Trivy**: Open-source scanner for container images, git repos, and more\n- **Clair**: Static analysis of container images\n- **Anchore**: Policy-based scanning and compliance\n\n### 3.2. Runtime Security\n\n- **Falco**: Real-time detection of suspicious activity in containers\n- **Sysdig**: Monitoring and security for containers and Kubernetes\n\n### 3.3. Compliance & Auditing\n\n- **Docker Bench for Security**: Automated security check for Docker hosts\n- **OpenSCAP**: Compliance checks and audits\n\n## 4. Example: Secure Dockerfile\n\n```dockerfile\nFROM alpine:3.18\nRUN adduser -D appuser\nUSER appuser\nCOPY app /app\nCMD [\"/app/start.sh\"]\n```\n\n- Slim image\n- No root user\n- Minimal attack surface\n\n## 5. Conclusion\n\nContainer security is an ongoing process. With the right tools, up-to-date images, and proven practices, you can significantly reduce risks. Automate security checks and stay informed about new threats‚Äîthis way, your container infrastructure remains secure and reliable.\n\n---\n\n**Further Reading:**\n\n- [Docker Security Best Practices](https://docs.docker.com/engine/security/)\n- [Trivy](https://github.com/aquasecurity/trivy)\n- [Falco](https://falco.org/)\n- [Docker Bench for Security](https://github.com/docker/docker-bench-security)"},{"id":"welcome-to-devsecops-unlocked","metadata":{"permalink":"/blog/welcome-to-devsecops-unlocked","source":"@site/blog/2025-12-06-welcome-to-devsecops-unlocked.md","title":"Welcome to DevSecOps Unlocked","description":"Welcome to DevSecOps Unlocked ‚Äì your comprehensive resource for bridging the gap between Development, Security, and Operations! üöÄüîí","date":"2025-12-06T00:00:00.000Z","tags":[{"inline":true,"label":"welcome","permalink":"/blog/tags/welcome"},{"inline":true,"label":"devsecops","permalink":"/blog/tags/devsecops"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"devops","permalink":"/blog/tags/devops"},{"inline":true,"label":"cloud","permalink":"/blog/tags/cloud"}],"readingTime":1.62,"hasTruncateMarker":true,"authors":[{"name":"Reik Loeber","title":"Fullstack Developer & DevOps & DevSecOps","url":"https://github.com/reiloe","imageURL":"https://github.com/reiloe.png","key":"reiloe","page":null}],"frontMatter":{"slug":"welcome-to-devsecops-unlocked","title":"Welcome to DevSecOps Unlocked","authors":["reiloe"],"tags":["welcome","devsecops","security","devops","cloud"]},"unlisted":false,"prevItem":{"title":"Docker Container Security","permalink":"/blog/docker-container-security"},"nextItem":{"title":"Kubernetes Security Guide","permalink":"/blog/kubernetes-security-best-practices"}},"content":"Welcome to **DevSecOps Unlocked** ‚Äì your comprehensive resource for bridging the gap between Development, Security, and Operations! üöÄüîí\n\nThis platform is designed to help you master the essential tools and practices that make modern cloud infrastructure secure, scalable, and efficient.\n\n<!--truncate-->\n\n## What You'll Find Here\n\n### üìö Comprehensive Cheat Sheets\n\nWe've created extensive command references for the tools you use every day:\n\n- **Cloud Platforms**: AWS CLI, Azure CLI, Google Cloud CLI\n- **Container & Orchestration**: Docker, Kubernetes\n- **Version Control**: Git\n- **System Administration**: Linux Shell Commands\n\nEach cheat sheet is packed with practical examples and real-world use cases to help you work more efficiently.\n\n### üéØ Hands-On Guides\n\nOur guides walk you through setting up complete lab environments, including:\n\n- OWASP Juice Shop security testing labs\n- Docker-based development environments\n- Cloud infrastructure setups\n\n### üîê Security-First Approach\n\nDevSecOps isn't just about speed ‚Äì it's about building security into every step of your development pipeline. Our content emphasizes:\n\n- Secure coding practices\n- Infrastructure as Code security\n- Container security\n- Cloud security best practices\n- Identity and Access Management\n\n## Why DevSecOps?\n\nTraditional approaches separate development, security, and operations into silos. DevSecOps breaks down these barriers by:\n\n1. **Shifting Security Left**: Integrating security early in the development process\n2. **Automating Everything**: Using CI/CD pipelines to ensure consistent, secure deployments\n3. **Continuous Monitoring**: Tracking security and performance in real-time\n4. **Collaborative Culture**: Breaking down silos between teams\n\n## What's Coming Next\n\nWe're continuously expanding our knowledge base with:\n\n- Terraform and Infrastructure as Code guides\n- CI/CD pipeline best practices\n- Security automation tutorials\n- Cloud architecture patterns\n- Real-world project challenges\n\n## Get Started\n\nReady to dive in? Check out our [Knowledge Base](/docs/knowledge-base/intro) to explore all available cheat sheets and guides.\n\nWhether you're a developer looking to enhance your security skills, a security professional learning DevOps tools, or an operations engineer embracing automation ‚Äì there's something here for you.\n\nLet's unlock the power of DevSecOps together! üéâ\n\n---\n\n*Have questions or suggestions? Feel free to reach out or contribute to this project.*"},{"id":"kubernetes-security-best-practices","metadata":{"permalink":"/blog/kubernetes-security-best-practices","source":"@site/blog/2025-11-15-kubernetes-security-best-practices.md","title":"Kubernetes Security Guide","description":"Securing a Kubernetes cluster is critical for protecting your workloads and data. In this guide, we'll explore essential security best practices that every DevSecOps engineer should implement.","date":"2025-11-15T00:00:00.000Z","tags":[{"inline":true,"label":"kubernetes","permalink":"/blog/tags/kubernetes"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"devsecops","permalink":"/blog/tags/devsecops"},{"inline":true,"label":"container-security","permalink":"/blog/tags/container-security"}],"readingTime":2.92,"hasTruncateMarker":true,"authors":[{"name":"Reik Loeber","title":"Fullstack Developer & DevOps & DevSecOps","url":"https://github.com/reiloe","imageURL":"https://github.com/reiloe.png","key":"reiloe","page":null}],"frontMatter":{"slug":"kubernetes-security-best-practices","title":"Kubernetes Security Guide","authors":["reiloe"],"tags":["kubernetes","security","devsecops","container-security"]},"unlisted":false,"prevItem":{"title":"Welcome to DevSecOps Unlocked","permalink":"/blog/welcome-to-devsecops-unlocked"},"nextItem":{"title":"Kubernetes Troubleshooting Guide","permalink":"/blog/kubernetes-troubleshooting-guide"}},"content":"Securing a Kubernetes cluster is critical for protecting your workloads and data. In this guide, we'll explore essential security best practices that every DevSecOps engineer should implement.\n\n<!--truncate-->\n\n## Why Kubernetes Security Matters\n\nKubernetes is a powerful orchestration platform, but its complexity introduces multiple attack vectors. From misconfigured RBAC to vulnerable container images, security must be built into every layer.\n\n## 1. Implement Role-Based Access Control (RBAC)\n\nRBAC is your first line of defense for controlling who can access what in your cluster.\n\n### Key Principles\n\n```yaml\n# Create a read-only role for developers\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-reader\n  namespace: development\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/log\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n```\n\n**Best Practices:**\n\n- Use the principle of least privilege\n- Create namespace-specific roles\n- Avoid using `cluster-admin` role unnecessarily\n- Regularly audit RBAC permissions\n\n## 2. Network Policies\n\nControl traffic between pods using Network Policies:\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-ingress\n  namespace: production\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n```\n\n**Implementation Tips:**\n\n- Start with deny-all policies\n- Explicitly allow required traffic\n- Segment namespaces with network policies\n- Use labels for fine-grained control\n\n## 3. Pod Security Standards\n\nEnable Pod Security Standards to prevent dangerous configurations:\n\n```yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: production\n  labels:\n    pod-security.kubernetes.io/enforce: restricted\n    pod-security.kubernetes.io/audit: restricted\n    pod-security.kubernetes.io/warn: restricted\n```\n\n**Security Contexts:**\n\n```yaml\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  allowPrivilegeEscalation: false\n  readOnlyRootFilesystem: true\n  capabilities:\n    drop:\n      - ALL\n```\n\n## 4. Secrets Management\n\nNever store secrets in plain text or in your Git repository.\n\n```bash\n# Use Kubernetes secrets\nkubectl create secret generic db-credentials \\\n  --from-literal=username=admin \\\n  --from-literal=password=secure-password\n\n# Better: Use external secret managers\n# - HashiCorp Vault\n# - AWS Secrets Manager\n# - Azure Key Vault\n```\n\n**Best Practices:**\n\n- Enable encryption at rest for etcd\n- Use external secret managers\n- Rotate secrets regularly\n- Limit secret access via RBAC\n\n## 5. Image Security\n\nScan and verify container images before deployment:\n\n```bash\n# Scan images for vulnerabilities\ntrivy image nginx:latest\n\n# Use only trusted registries\n# Implement image signing with Cosign\ncosign sign --key cosign.key myregistry/myimage:v1.0\n```\n\n**Image Policy:**\n\n- Use minimal base images (Alpine, Distroless)\n- Scan images in CI/CD pipeline\n- Implement image admission controllers\n- Keep images updated\n\n## 6. Audit Logging\n\nEnable and monitor audit logs:\n\n```yaml\n# Enable audit logging in API server\n--audit-log-path=/var/log/kubernetes/audit.log\n--audit-log-maxage=30\n--audit-log-maxbackup=10\n--audit-log-maxsize=100\n--audit-policy-file=/etc/kubernetes/audit-policy.yaml\n```\n\n**What to Monitor:**\n\n- Failed authentication attempts\n- Privilege escalation\n- Secret access\n- Resource modifications\n\n## 7. Resource Limits and Quotas\n\nPrevent resource exhaustion attacks:\n\n```yaml\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: compute-quota\n  namespace: development\nspec:\n  hard:\n    requests.cpu: \"10\"\n    requests.memory: 20Gi\n    limits.cpu: \"20\"\n    limits.memory: 40Gi\n```\n\n## 8. Secure the Control Plane\n\n- Use private clusters when possible\n- Enable API server authentication\n- Restrict API server access with firewall rules\n- Keep Kubernetes updated\n- Use managed Kubernetes services (EKS, AKS, GKE)\n\n## Security Checklist\n\n- [ ] RBAC configured with least privilege\n- [ ] Network policies implemented\n- [ ] Pod Security Standards enabled\n- [ ] Secrets encrypted at rest\n- [ ] Image scanning in CI/CD\n- [ ] Audit logging enabled\n- [ ] Resource quotas defined\n- [ ] Control plane secured\n- [ ] Regular security audits\n- [ ] Incident response plan\n\n## Tools for Kubernetes Security\n\n- **Trivy**: Vulnerability scanner\n- **Falco**: Runtime security monitoring\n- **OPA/Gatekeeper**: Policy enforcement\n- **Kyverno**: Kubernetes-native policy management\n- **Kubescape**: Security compliance scanning\n\n## Conclusion\n\nKubernetes security is not a one-time setup but an ongoing process. Implement these best practices, regularly audit your clusters, and stay updated with the latest security recommendations.\n\nRemember: **Security is everyone's responsibility** in a DevSecOps culture.\n\n---\n\n*Check out our [Kubernetes Commands Cheat Sheet](/docs/knowledge-base/cheat-sheets/kubernetes-commands) for quick reference!*"},{"id":"kubernetes-troubleshooting-guide","metadata":{"permalink":"/blog/kubernetes-troubleshooting-guide","source":"@site/blog/2025-10-22-kubernetes-troubleshooting-guide.md","title":"Kubernetes Troubleshooting Guide","description":"Kubernetes troubleshooting can be challenging, especially when dealing with complex distributed systems.","date":"2025-10-22T00:00:00.000Z","tags":[{"inline":true,"label":"kubernetes","permalink":"/blog/tags/kubernetes"},{"inline":true,"label":"troubleshooting","permalink":"/blog/tags/troubleshooting"},{"inline":true,"label":"debugging","permalink":"/blog/tags/debugging"},{"inline":true,"label":"operations","permalink":"/blog/tags/operations"}],"readingTime":5.38,"hasTruncateMarker":true,"authors":[{"name":"Reik Loeber","title":"Fullstack Developer & DevOps & DevSecOps","url":"https://github.com/reiloe","imageURL":"https://github.com/reiloe.png","key":"reiloe","page":null}],"frontMatter":{"slug":"kubernetes-troubleshooting-guide","title":"Kubernetes Troubleshooting Guide","authors":["reiloe"],"tags":["kubernetes","troubleshooting","debugging","operations"]},"unlisted":false,"prevItem":{"title":"Kubernetes Security Guide","permalink":"/blog/kubernetes-security-best-practices"},"nextItem":{"title":"Kubernetes Networking Demystified: A Practical Guide","permalink":"/blog/kubernetes-networking-explained"}},"content":"Kubernetes troubleshooting can be challenging, especially when dealing with complex distributed systems.\n\nThis guide covers essential techniques and commands to diagnose and fix common issues quickly.\n\n<!--truncate-->\n\n## The Troubleshooting Mindset\n\nBefore diving into commands, remember these principles:\n\n1. **Start broad, then narrow down**: Check cluster health ‚Üí node status ‚Üí pod status ‚Üí logs\n2. **Check recent changes**: What was deployed or modified recently?\n3. **Use the right tools**: kubectl, logs, events, and metrics\n4. **Document your findings**: Help your future self and your team\n\n## Common Issues and Solutions\n\n### 1. Pod Not Starting (CrashLoopBackOff)\n\n**Symptoms:**\n\n```bash\n$ kubectl get pods\nNAME                     READY   STATUS             RESTARTS   AGE\nmyapp-7d8f5c9b4d-xyz12   0/1     CrashLoopBackOff   5          3m\n```\n\n**Diagnosis:**\n\n```bash\n# Check pod description for events\nkubectl describe pod myapp-7d8f5c9b4d-xyz12\n\n# Check logs (current container)\nkubectl logs myapp-7d8f5c9b4d-xyz12\n\n# Check logs (previous crashed container)\nkubectl logs myapp-7d8f5c9b4d-xyz12 --previous\n\n# Check all containers in pod\nkubectl logs myapp-7d8f5c9b4d-xyz12 --all-containers\n```\n\n**Common Causes:**\n\n- Application crashes on startup\n- Missing environment variables\n- Failed health checks\n- Insufficient permissions\n- Missing dependencies\n\n**Example Fix:**\n\n```bash\n# Check if ConfigMap/Secret exists\nkubectl get configmap myapp-config\nkubectl get secret myapp-secret\n\n# Verify environment variables\nkubectl get pod myapp-7d8f5c9b4d-xyz12 -o yaml | grep -A 10 env:\n```\n\n### 2. ImagePullBackOff\n\n**Symptoms:**\n\n```bash\n$ kubectl get pods\nNAME                     READY   STATUS             RESTARTS   AGE\nmyapp-7d8f5c9b4d-xyz12   0/1     ImagePullBackOff   0          2m\n```\n\n**Diagnosis:**\n\n```bash\n# Check events\nkubectl describe pod myapp-7d8f5c9b4d-xyz12 | grep -A 5 Events\n\n# Common error messages:\n# - \"pull access denied\" ‚Üí Authentication issue\n# - \"manifest unknown\" ‚Üí Image doesn't exist\n# - \"connection timeout\" ‚Üí Network/registry issue\n```\n\n**Solutions:**\n\n```bash\n# Verify image name and tag\nkubectl get deployment myapp -o yaml | grep image:\n\n# Check if image exists\ndocker pull myregistry/myapp:v1.0\n\n# Verify image pull secrets\nkubectl get secrets\nkubectl describe secret regcred\n\n# Create image pull secret if missing\nkubectl create secret docker-registry regcred \\\n  --docker-server=myregistry.azurecr.io \\\n  --docker-username=myuser \\\n  --docker-password=mypassword \\\n  --docker-email=myemail@example.com\n\n# Add to pod spec\nkubectl patch serviceaccount default \\\n  -p '{\"imagePullSecrets\": [{\"name\": \"regcred\"}]}'\n```\n\n### 3. Pending Pods (Not Scheduled)\n\n**Symptoms:**\n\n```bash\n$ kubectl get pods\nNAME                     READY   STATUS    RESTARTS   AGE\nmyapp-7d8f5c9b4d-xyz12   0/1     Pending   0          5m\n```\n\n**Diagnosis:**\n\n```bash\n# Check scheduling events\nkubectl describe pod myapp-7d8f5c9b4d-xyz12\n\n# Check node resources\nkubectl top nodes\nkubectl describe nodes\n\n# Check for taints and tolerations\nkubectl get nodes -o custom-columns=NAME:.metadata.name,TAINTS:.spec.taints\n```\n\n**Common Causes:**\n\n- Insufficient CPU/Memory\n- No nodes match node selectors\n- Node taints without tolerations\n- PersistentVolume not available\n\n**Solutions:**\n\n```bash\n# Scale down other deployments\nkubectl scale deployment other-app --replicas=1\n\n# Remove node selector if too restrictive\nkubectl patch deployment myapp \\\n  -p '{\"spec\":{\"template\":{\"spec\":{\"nodeSelector\":null}}}}'\n\n# Add toleration for tainted nodes\nkubectl patch deployment myapp --type=json -p='[{\n  \"op\": \"add\",\n  \"path\": \"/spec/template/spec/tolerations\",\n  \"value\": [{\n    \"key\": \"key1\",\n    \"operator\": \"Equal\",\n    \"value\": \"value1\",\n    \"effect\": \"NoSchedule\"\n  }]\n}]'\n```\n\n### 4. Service Not Accessible\n\n**Symptoms:**\n\n- Can't reach application via Service\n- Connection timeouts\n- DNS resolution fails\n\n**Diagnosis:**\n\n```bash\n# Check service endpoints\nkubectl get svc myapp-service\nkubectl get endpoints myapp-service\n\n# If endpoints are empty, pods aren't matching selector\nkubectl get pods --selector=app=myapp\n\n# Test DNS resolution\nkubectl run -it --rm debug --image=busybox --restart=Never -- nslookup myapp-service\n\n# Test connectivity from another pod\nkubectl run -it --rm debug --image=nicolaka/netshoot --restart=Never -- bash\ncurl http://myapp-service:8080\n```\n\n**Solutions:**\n\n```bash\n# Verify service selector matches pod labels\nkubectl get service myapp-service -o yaml\nkubectl get pods --show-labels\n\n# Check if pods are ready\nkubectl get pods -l app=myapp\n\n# Port-forward for direct testing\nkubectl port-forward svc/myapp-service 8080:80\n```\n\n### 5. High Resource Usage\n\n**Diagnosis:**\n\n```bash\n# Check resource usage\nkubectl top nodes\nkubectl top pods\nkubectl top pods --all-namespaces --sort-by=memory\nkubectl top pods --all-namespaces --sort-by=cpu\n\n# Check resource limits\nkubectl describe pod myapp-7d8f5c9b4d-xyz12 | grep -A 5 \"Limits\\|Requests\"\n\n# Check for OOMKilled pods\nkubectl get pods --all-namespaces | grep OOMKilled\n```\n\n**Solutions:**\n\n```bash\n# Add/adjust resource limits\nkubectl set resources deployment myapp \\\n  --limits=cpu=500m,memory=512Mi \\\n  --requests=cpu=250m,memory=256Mi\n\n# Horizontal Pod Autoscaling\nkubectl autoscale deployment myapp --min=2 --max=10 --cpu-percent=70\n```\n\n## Essential Troubleshooting Commands\n\n### Quick Status Check\n\n```bash\n# Cluster overview\nkubectl cluster-info\nkubectl get componentstatuses\n\n# Node health\nkubectl get nodes\nkubectl describe node <node-name>\n\n# All resources\nkubectl get all --all-namespaces\n\n# Events (recent issues)\nkubectl get events --sort-by='.lastTimestamp' --all-namespaces\nkubectl get events --field-selector type=Warning --all-namespaces\n```\n\n### Deep Dive Commands\n\n```bash\n# Execute commands in pod\nkubectl exec -it myapp-7d8f5c9b4d-xyz12 -- /bin/bash\nkubectl exec -it myapp-7d8f5c9b4d-xyz12 -- ps aux\nkubectl exec -it myapp-7d8f5c9b4d-xyz12 -- env\n\n# Copy files from/to pod\nkubectl cp myapp-7d8f5c9b4d-xyz12:/app/logs/error.log ./local-error.log\nkubectl cp ./config.yaml myapp-7d8f5c9b4d-xyz12:/app/config.yaml\n\n# Debug with ephemeral containers (K8s 1.23+)\nkubectl debug myapp-7d8f5c9b4d-xyz12 -it --image=busybox --target=myapp\n\n# Check API server logs (for managed clusters)\nkubectl logs -n kube-system -l component=kube-apiserver\n```\n\n### Network Debugging\n\n```bash\n# Deploy debug pod\nkubectl run debug --image=nicolaka/netshoot -it --rm -- bash\n\n# Inside debug pod:\nnslookup kubernetes.default\ncurl -v http://myapp-service:8080\ntraceroute myapp-service\nnetstat -tunlp\n```\n\n## Troubleshooting Workflow\n\n1. **Identify the problem scope**\n   - Single pod? Multiple pods? Entire deployment?\n   - Specific namespace or cluster-wide?\n\n2. **Gather information**\n\n   ```bash\n   kubectl get pods -o wide\n   kubectl describe pod <pod-name>\n   kubectl logs <pod-name>\n   kubectl get events --sort-by='.lastTimestamp'\n   ```\n\n3. **Analyze and hypothesize**\n   - What changed recently?\n   - Are there patterns in errors?\n   - Is it infrastructure or application?\n\n4. **Test and validate**\n   - Make one change at a time\n   - Document what you try\n   - Roll back if it doesn't help\n\n5. **Monitor and verify**\n   - Check if issue is resolved\n   - Monitor for recurrence\n   - Update documentation\n\n## Pro Tips\n\n- **Use aliases**: `alias k=kubectl`, `alias kgp='kubectl get pods'`\n- **Context switching**: `kubectl config use-context production`\n- **JSON/YAML output**: `kubectl get pod myapp -o yaml` for full details\n- **Watch mode**: `kubectl get pods --watch` for real-time updates\n- **Stern for logs**: `stern myapp` for multi-pod log tailing\n- **K9s**: Terminal UI for easier navigation\n\n## Prevention is Better Than Cure\n\n- Implement proper health checks (liveness/readiness probes)\n- Set resource requests and limits\n- Use Pod Disruption Budgets\n- Monitor with Prometheus/Grafana\n- Set up alerts for critical issues\n- Regular cluster audits\n\n## Conclusion\n\nEffective Kubernetes troubleshooting comes with practice. Build your mental model of how components interact, use these commands as your toolkit, and document your learnings.\n\nRemember: **Every issue is a learning opportunity!**\n\n---\n\n*Need quick command references? Check our [Kubernetes Commands Cheat Sheet](/docs/knowledge-base/cheat-sheets/kubernetes-commands).*"},{"id":"kubernetes-networking-explained","metadata":{"permalink":"/blog/kubernetes-networking-explained","source":"@site/blog/2025-09-18-kubernetes-networking-explained.md","title":"Kubernetes Networking Demystified: A Practical Guide","description":"Kubernetes networking can seem complex at first, but understanding the fundamentals is crucial for building reliable applications. Let's break down how networking works in Kubernetes with practical examples.","date":"2025-09-18T00:00:00.000Z","tags":[{"inline":true,"label":"kubernetes","permalink":"/blog/tags/kubernetes"},{"inline":true,"label":"networking","permalink":"/blog/tags/networking"},{"inline":true,"label":"infrastructure","permalink":"/blog/tags/infrastructure"},{"inline":true,"label":"containers","permalink":"/blog/tags/containers"}],"readingTime":5.53,"hasTruncateMarker":true,"authors":[{"name":"Reik Loeber","title":"Fullstack Developer & DevOps & DevSecOps","url":"https://github.com/reiloe","imageURL":"https://github.com/reiloe.png","key":"reiloe","page":null}],"frontMatter":{"slug":"kubernetes-networking-explained","title":"Kubernetes Networking Demystified: A Practical Guide","authors":["reiloe"],"tags":["kubernetes","networking","infrastructure","containers"]},"unlisted":false,"prevItem":{"title":"Kubernetes Troubleshooting Guide","permalink":"/blog/kubernetes-troubleshooting-guide"}},"content":"Kubernetes networking can seem complex at first, but understanding the fundamentals is crucial for building reliable applications. Let's break down how networking works in Kubernetes with practical examples.\n\n<!--truncate-->\n\n## The Four Pillars of Kubernetes Networking\n\nKubernetes networking is built on four key principles:\n\n1. **Pod-to-Pod communication** without NAT\n2. **Node-to-Pod communication** without NAT\n3. **Pod IP addresses** are consistent (from pod's perspective)\n4. **Container-to-Container** within a pod via localhost\n\n## Understanding the Network Model\n\n### 1. Container-to-Container (within a Pod)\n\nContainers in the same pod share the same network namespace:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: multi-container-pod\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n    ports:\n    - containerPort: 80\n  - name: sidecar\n    image: busybox\n    command: ['sh', '-c', 'while true; do wget -O- localhost:80; sleep 5; done']\n```\n\n**Key Point**: The sidecar can reach nginx via `localhost:80` because they share the network namespace.\n\n### 2. Pod-to-Pod Communication\n\nEvery pod gets its own IP address. Pods can communicate directly:\n\n```bash\n# Pod A (10.244.1.5)\n$ kubectl exec pod-a -- curl http://10.244.2.8:8080\n\n# Pod B (10.244.2.8) receives the request\n```\n\n**How it works:**\n\n- Each node runs a CNI plugin (Calico, Flannel, Cilium, etc.)\n- CNI creates virtual network interfaces\n- Routes traffic between pods across nodes\n- No NAT required!\n\n### 3. Pod-to-Service Communication\n\nServices provide stable IPs and DNS names for pod groups:\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n  type: ClusterIP\n```\n\n**Service Types:**\n\n#### ClusterIP (Default)\n\n- Internal cluster access only\n- Stable internal IP\n- Use for: Database, internal APIs\n\n```bash\n# Access from within cluster\ncurl http://backend-service:80\ncurl http://backend-service.default.svc.cluster.local:80\n```\n\n#### NodePort\n\n- Exposes service on each node's IP\n- Port range: 30000-32767\n- Use for: Development, simple external access\n\n```yaml\nspec:\n  type: NodePort\n  ports:\n  - port: 80\n    targetPort: 8080\n    nodePort: 30080\n```\n\n```bash\n# Access from outside cluster\ncurl http://<node-ip>:30080\n```\n\n#### LoadBalancer\n\n- Cloud provider provisions external load balancer\n- Use for: Production external services\n\n```yaml\nspec:\n  type: LoadBalancer\n  ports:\n  - port: 80\n    targetPort: 8080\n```\n\n#### ExternalName\n\n- Maps service to external DNS name\n- Use for: External databases, legacy systems\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-db\nspec:\n  type: ExternalName\n  externalName: database.example.com\n```\n\n## DNS in Kubernetes\n\nKubernetes has built-in DNS (CoreDNS). Every service gets DNS records:\n\n### Service DNS Format\n\n```\n<service-name>.<namespace>.svc.cluster.local\n```\n\n**Examples:**\n\n```bash\n# Same namespace\ncurl http://backend-service\n\n# Different namespace\ncurl http://backend-service.production\n\n# Fully qualified\ncurl http://backend-service.production.svc.cluster.local\n```\n\n### DNS for Pods (Headless Services)\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: database\nspec:\n  clusterIP: None  # Headless service\n  selector:\n    app: postgres\n  ports:\n  - port: 5432\n```\n\nAccess individual pod IPs:\n\n```bash\n# DNS records for each pod\ndatabase-0.database.default.svc.cluster.local\ndatabase-1.database.default.svc.cluster.local\ndatabase-2.database.default.svc.cluster.local\n```\n\n## Ingress: HTTP/HTTPS Routing\n\nIngress provides HTTP(S) routing to services:\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: app.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service\n            port:\n              number: 80\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080\n  tls:\n  - hosts:\n    - app.example.com\n    secretName: tls-secret\n```\n\n**Popular Ingress Controllers:**\n\n- NGINX Ingress Controller\n- Traefik\n- HAProxy\n- AWS ALB Ingress Controller\n- GKE Ingress\n\n## Network Policies\n\nControl traffic between pods:\n\n### Default Deny All Ingress\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny-ingress\n  namespace: production\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n```\n\n### Allow Specific Traffic\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-frontend-to-backend\n  namespace: production\nspec:\n  podSelector:\n    matchLabels:\n      app: backend\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 8080\n```\n\n### Allow Egress to External API\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-external-api\nspec:\n  podSelector:\n    matchLabels:\n      app: backend\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - podSelector: {}  # Same namespace\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: kube-system\n  - to:  # External API\n    ports:\n    - protocol: TCP\n      port: 443\n```\n\n## CNI Plugins Comparison\n\n### Calico\n\n- **Pros**: High performance, network policies, BGP routing\n- **Best for**: Large clusters, security-focused\n- **Use case**: Enterprise production\n\n### Flannel\n\n- **Pros**: Simple, easy setup, lightweight\n- **Best for**: Development, small clusters\n- **Use case**: Learning, testing\n\n### Cilium\n\n- **Pros**: eBPF-based, advanced features, observability\n- **Best for**: Modern clusters, service mesh\n- **Use case**: High-performance production\n\n### Weave Net\n\n- **Pros**: Automatic, easy encryption\n- **Best for**: Quick setup, encrypted networking\n- **Use case**: Multi-cloud deployments\n\n## Practical Networking Examples\n\n### Multi-Tier Application\n\n```yaml\n# Frontend Service (LoadBalancer)\napiVersion: v1\nkind: Service\nmetadata:\n  name: frontend\nspec:\n  type: LoadBalancer\n  selector:\n    tier: frontend\n  ports:\n  - port: 80\n    targetPort: 3000\n---\n# Backend Service (ClusterIP)\napiVersion: v1\nkind: Service\nmetadata:\n  name: backend\nspec:\n  type: ClusterIP\n  selector:\n    tier: backend\n  ports:\n  - port: 8080\n    targetPort: 8080\n---\n# Database Service (Headless)\napiVersion: v1\nkind: Service\nmetadata:\n  name: database\nspec:\n  clusterIP: None\n  selector:\n    tier: database\n  ports:\n  - port: 5432\n```\n\n### Network Policy Strategy\n\n```yaml\n# 1. Deny all traffic by default\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny-all\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n---\n# 2. Allow frontend -> backend\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-to-backend\nspec:\n  podSelector:\n    matchLabels:\n      tier: backend\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          tier: frontend\n---\n# 3. Allow backend -> database\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: backend-to-database\nspec:\n  podSelector:\n    matchLabels:\n      tier: database\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          tier: backend\n```\n\n## Debugging Network Issues\n\n### Test Connectivity\n\n```bash\n# Create debug pod\nkubectl run test-pod --image=nicolaka/netshoot -it --rm -- bash\n\n# Inside debug pod\n# Test DNS\nnslookup backend-service\nnslookup backend-service.production.svc.cluster.local\n\n# Test connectivity\ncurl -v http://backend-service:8080\nping 10.244.1.5\n\n# Check routes\nip route\ntraceroute backend-service\n```\n\n### Check Service Endpoints\n\n```bash\n# Verify service has endpoints\nkubectl get endpoints backend-service\n\n# If empty, check pod labels\nkubectl get pods --show-labels\nkubectl get service backend-service -o yaml\n```\n\n### Verify Network Policy\n\n```bash\n# List network policies\nkubectl get networkpolicies\n\n# Describe policy\nkubectl describe networkpolicy allow-frontend-to-backend\n\n# Test if traffic is blocked\nkubectl run test-curl --image=curlimages/curl -it --rm -- \\\n  curl http://backend-service:8080\n```\n\n## Best Practices\n\n1. **Use Network Policies**: Default deny, explicit allow\n2. **Choose the right Service type**: ClusterIP for internal, LoadBalancer for external\n3. **Implement Ingress**: For HTTP(S) routing and TLS termination\n4. **Monitor network traffic**: Use tools like Cilium Hubble or Calico Enterprise\n5. **Test network policies**: Before deploying to production\n6. **Use DNS names**: Not IP addresses for service discovery\n7. **Secure inter-service communication**: Consider service mesh for mTLS\n\n## Conclusion\n\nKubernetes networking is powerful once you understand the fundamentals. Start simple with Services and DNS, then add Ingress and Network Policies as needed.\n\nThe key is to think in terms of:\n\n- **Services** for stable endpoints\n- **DNS** for discovery\n- **Network Policies** for security\n- **Ingress** for external access\n\nMaster these concepts, and you'll be confident deploying any application architecture on Kubernetes!\n\n---\n\n*Looking for quick networking commands? Check out our [Kubernetes Commands Cheat Sheet](/docs/knowledge-base/cheat-sheets/kubernetes-commands).*"}]}}